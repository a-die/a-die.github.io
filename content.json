{"meta":{"title":"a碟のBlog","subtitle":"","description":"","author":"a碟","url":"https://a-die.github.io","root":"/"},"pages":[{"title":"about","date":"2022-11-08T13:48:00.000Z","updated":"2022-11-08T13:48:00.094Z","comments":true,"path":"about/index.html","permalink":"https://a-die.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-08T13:47:14.000Z","updated":"2022-11-08T14:22:33.284Z","comments":false,"path":"categories/index.html","permalink":"https://a-die.github.io/categories/index.html","excerpt":"","text":""},{"title":"resources","date":"2022-11-08T13:48:02.000Z","updated":"2022-11-08T13:48:02.357Z","comments":true,"path":"resources/index.html","permalink":"https://a-die.github.io/resources/index.html","excerpt":"","text":""},{"title":"我的小伙伴们","date":"2022-11-08T14:18:41.000Z","updated":"2022-11-11T01:57:15.736Z","comments":true,"path":"links/index.html","permalink":"https://a-die.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-09T03:11:58.000Z","updated":"2022-11-09T03:20:26.361Z","comments":false,"path":"tags/index.html","permalink":"https://a-die.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"目标检测算法","slug":"目标检测算法","date":"2023-09-13T13:05:52.369Z","updated":"2023-09-13T13:10:00.839Z","comments":true,"path":"2023/09/13/目标检测算法/","link":"","permalink":"https://a-die.github.io/2023/09/13/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/","excerpt":"区域卷积神经网络(R-CNN)系列区域卷积神经网络(region-based CNN或regions with CNN features，R-CNN) 快速的R-CNN(Fast R-CNN) 更快的R-CNN(Faster R-CNN) 掩码R-CNN(Mask R-CNN)","text":"区域卷积神经网络(R-CNN)系列区域卷积神经网络(region-based CNN或regions with CNN features，R-CNN) 快速的R-CNN(Fast R-CNN) 更快的R-CNN(Faster R-CNN) 掩码R-CNN(Mask R-CNN) R-CNNR-CNN首先从输入图像中选取若干个(如2000个)提议区域(如锚框)，标注他们的类别和边界框。然后，用CNN对每个提议区域提取特征。然后用每个提议区域的特征来预测类别和边界框。 如何选取一开始的提议区域，就是使用选择性搜索这样一种办法。 具体步骤如下： 对输入图像使用选择性搜索来得到多个高质量的提议区域(锚框)。这些提议区域通常是在多个尺度下选取的，具有不同的形状和大小(如之前所看到的锚框的选取方法)。每个提议区域都要被标注类别和真实边界框(就是打上label)。 然后选择一个预训练的CNN(在输出层之前截断)。将每个提议区域变形为网络需要的输入尺寸，然后通过CNN抽取特征。 将每个提议区域的特征连同其标注的类别作为一个样本。训练多个支持向量机SVM对目标进行分类，其中每个SVM用来判断的是样本是否属于某一个类别。 将每个提议区域的特征连同其标注的边界框作为一个样本，训练线性回归模型来预测真实边界框。 不难想到，对每一个图像，我们都可能选取出上千个提议区域，这需要的是上千次的CNN前向传播来提取特征，从而执行目标检测。计算量过于庞大。 Fast R-CNNR-CNN之所以慢，是因为其对每一个提议区域，CNN的前向传播特征提取是独立的，没有共享计算。可能存在多个提议区域重叠，独立的特征抽取会导致重复的计算。 Fast R-CNN对R-CNN的主要改进之一就是仅仅在整张图象上执行卷积神经网络的前向传播，即提取特征。 主要步骤如下： 和R-CNN相比，Fast R-CNN用来提取特征的CNN的输入是整张图象，并不是各个提议区域。而且，这个提取特征的网络将参与训练，设输入为一张图像，CNN的输出的形状记为$1 \\times c \\times h_{1} \\times \\omega_{1}$。 在选择性搜索之后，得到多个高质量的提议区域(锚框)，假设生成了n个提议区域。这些形状各异的提议区域在卷积神经网络的输出上分别标出了形状各异的兴趣区域(比如按照比例在原图上的锚框映射到输出特征上)。 然后，这些感兴趣的区域需要进一步抽取出形状相同的特征(比如需要指定高度$h_{2}$和宽度$\\omega_{2}$)，以便于连结后输出。Fast R-CNN使用的方法是引入兴趣区域汇聚层(RoI pooling)：将CNN的输出(特征)和提议区域作为输入，输出连结后的各个提议区域抽取的特征，形状为$n \\times c \\times h_{2} \\times \\omega_{2}$。 通过全连接层将输出的形状变为$n \\times d$，其中超参数$d$取决于模型设计。 预测n个提议区域中每个区域的类别和边界框。即在预测类别和边界框时，将全连接层的输出分别转换为形状为$n \\times q$(q是类别的数量)的输出和形状为$n \\times 4$的输出(一个输出的是类别概率，一个输出的是边界框的坐标表示)。其中预测类别时使用softmax回归。 关于兴趣汇聚层(RoI pooling)，具体做法是： 指定每个区域的高和宽分别为$h_{2}$和$\\omega_{2}$。对于任何形状为$h \\times \\omega$的兴趣区域窗口，都将被划分为$h_{2} \\times \\omega_{2}$的子窗口网络。每个子窗口的大小约为$(h&#x2F;h_{2}) \\times (\\omega &#x2F; \\omega_{2})$，向上取整，其中每个子窗口中的最大元素作为该子窗口的输出。因此，RoI pooling可以从形状各异的兴趣区域中抽取出形状相同的特征。 Faster R-CNN为了精确检测目标结果，Fast R-CNN模型需要在选择性搜索中生成大量的提议区域。Faster R-CNN则提出将选择性搜索替换为区域提议网络(region proposal netword,rpn)。从而减少提议区域的生成数量，并且保证目标检测的精度。 实际上就是将获得提议区域的过程变成了使用神经网络来训练获得提议区域的过程。 与Fast R-CNN相比，Faster R-CNN只是将生成提议区域的方法从选择性搜索改为了区域提议网络，模型其余部分保持不变。(可以说是多了一个粗糙的对锚框进行分类和预测的过程) 区域提议网络操作步骤如下： 使用填充为1的$3 \\times 3$的卷积层变换卷积神经网络的输出，并将通道数记为c。这样，卷积神经网络为图像抽取的特征图中的每个单元均得到一个长度为c的新特征。 以特征图的每个像素为中心，生成多个不同大小和宽高比的锚框并标注它们(也可以使用选择性搜索方法来生成)。 使用锚框中心单元长度为c的特征，分别预测该锚框的二元类别(含目标还是背景)和边界框。 使用非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测边界框是兴趣区域汇聚层所需的提议区域。 区域提议网络rpn是和整个模型一起训练得到的。所以，Faster R-CNN的目标函数不仅包括目标检测中的类别和边界框的预测，还包括区域提议网络锚框的二元类别和边界框预测。因此，其还可以学到如何生成高质量的提议区域。 Mask R-CNN如果在训练集中还标注了每个目标在图像上的像素级的位置，那么Mask R-CNN能够有效利用这些详尽标注信息进一步提升目标检测的精度。 Mask R-CNN是基于Faster R-CNN修改而来。 其将兴趣区域汇聚层换成了兴趣区域对齐层(主要区别就在RoI pooling是可能会将兴趣区域改变形状的，而RoI Align不会，在无法整除时，它会将一部分区域拆分出来)。使用双线性插值(bilinear interpolation)来保留特征图上的空间信息，从而更适于像素级预测。 兴趣区域对齐层的输出包含了所有与兴趣区域的形状相同的特征图。 它们不仅被用于预测每个兴趣区域的类别和边界框，还通过额外的全卷积网络预测目标的像素级位置。 单发多框检测(SSD)模型 此模型主要由基础网络组成，其后是几个多尺度特征块。 基本网络用于从输入图像中提取特征，因此它可以使用深度卷积神经网络。 单发多框检测论文中选用了在分类层之前截断的VGG (Liu et al., 2016)，现在也常用ResNet替代。 我们可以设计基础网络，使它输出的高和宽较大。 这样一来，基于该特征图生成的锚框数量较多，可以用来检测尺寸较小的目标。 接下来的每个多尺度特征块将上一层提供的特征图的高和宽缩小（如减半），并使特征图中每个单元在输入图像上的感受野变得更广阔。 接近图顶部的多尺度特征图较小，但是其具有较大的感受野，所以适合检测较少但较大的物体。 通过多尺度特征块，单发多框检测生成不同大小的锚框，通过预测边界框的类别和偏移量来检测大小不同的目标。","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"研究生方向","slug":"研究生方向","permalink":"https://a-die.github.io/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B9%E5%90%91/"},{"name":"深度学习","slug":"深度学习","permalink":"https://a-die.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"目标检测基本概念","slug":"目标检测基本概念","date":"2023-09-12T12:38:49.939Z","updated":"2023-09-12T12:40:13.556Z","comments":true,"path":"2023/09/12/目标检测基本概念/","link":"","permalink":"https://a-die.github.io/2023/09/12/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"写在前面目前暂定方向： 先考虑单无人机，解决多目标检测、定位与目标移动轨迹预测问题。 后续，从多个无人机的视角中检测出同一个物体，多视角的目标检测问题，应该侧重的难点在于多个摄像头的数据融合，视角变化等的问题。 所以目前应该先学习一下目标检测的基本知识，考虑到之前对CV有一些基本的了解，因此直接看目标检测知识。 参考视频&#x2F;书籍： 动手学深度学习(李沐) up主——霹雳吧啦Wz(深度学习-目标检测篇)，其提供了大量的实战代码，很简单上手(不会目标检测的人也能拿他代码轻松跑通) 在对目标检测基础知识了解完成之后，开始去kaggle&#x2F;天池参加简单的目标检测比赛(参加经典的比赛，论坛讨论人数多，可参考代码多) 然后读当前方向相关论文，总结idea，得出新idea","text":"写在前面目前暂定方向： 先考虑单无人机，解决多目标检测、定位与目标移动轨迹预测问题。 后续，从多个无人机的视角中检测出同一个物体，多视角的目标检测问题，应该侧重的难点在于多个摄像头的数据融合，视角变化等的问题。 所以目前应该先学习一下目标检测的基本知识，考虑到之前对CV有一些基本的了解，因此直接看目标检测知识。 参考视频&#x2F;书籍： 动手学深度学习(李沐) up主——霹雳吧啦Wz(深度学习-目标检测篇)，其提供了大量的实战代码，很简单上手(不会目标检测的人也能拿他代码轻松跑通) 在对目标检测基础知识了解完成之后，开始去kaggle&#x2F;天池参加简单的目标检测比赛(参加经典的比赛，论坛讨论人数多，可参考代码多) 然后读当前方向相关论文，总结idea，得出新idea 目标检测和边界框在之前所做的图像分类任务中，我们只关注如何识别其类别。然而，在CV领域，我们更感兴趣的不仅是他们的类别，还有他们在图像中的具体位置。这种任务我们便将它称为目标检测(object detection)或目标识别(object recognition)。 目标检测目前在多个领域被广泛应用，在无人驾驶里，我们需要通过识别拍摄到的视频图像里的车辆、行人、道路和障碍物的位置来规划行进线路。 机器人也常通过该任务来检测感兴趣的目标。安防领域则需要检测异常目标，如歹徒或者炸弹。 边界框在object detection中，我们经常使用边界框(bounding box)来描述对象的空间位置。 bounding box是矩形的，其表示方法一般有： 矩形左上角及右下角的x,y坐标决定 边界框重心的(x,y)轴坐标，以及框的宽度和高度 两者的转换方式可以在《动手学深度学习》中找到 123456789101112131415161718192021#@savedef box_corner_to_center(boxes): &quot;&quot;&quot;从（左上，右下）转换到（中间，宽度，高度）&quot;&quot;&quot; x1, y1, x2, y2 = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3] cx = (x1 + x2) / 2 cy = (y1 + y2) / 2 w = x2 - x1 h = y2 - y1 boxes = torch.stack((cx, cy, w, h), axis=-1) return boxes#@savedef box_center_to_corner(boxes): &quot;&quot;&quot;从（中间，宽度，高度）转换到（左上，右下）&quot;&quot;&quot; cx, cy, w, h = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3] x1 = cx - 0.5 * w y1 = cy - 0.5 * h x2 = cx + 0.5 * w y2 = cy + 0.5 * h boxes = torch.stack((x1, y1, x2, y2), axis=-1) return boxes 锚框在目标检测算法中，通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并且调整区域边界，从而更准确地预测目标的真实边界框(ground-truth bounding box)。 在后续，介绍的不同模型中，使用的区域采样方法可能不同，现在先介绍其中一种方法：以每一个像素为中心，生成多个缩放比(scale)和宽高比(aspect ratio)不同的边界框。这些边界框称为锚框(anchor box)。 生成多个锚框对于锚框的生成方法，我目前不打算具体的深入了解。只需了解大致方法。 在《动手学深度学习》一书中，李沐老师所述方法为：以图像的每个像素为重心，生成不同形状的锚框：缩放比为$s∈(0,1]$，宽高比为$r&gt;0$。 那么锚框的宽度和高度分别是$ℎs\\sqrt r$和$ℎs&#x2F;\\sqrt r$。 请注意，当中心位置给定时，已知宽和高的锚框是确定的。 要生成多个不同形状的锚框，让我们设置许多缩放比（scale）取值$s_{1},…,s_{n}$和许多宽高比（aspect ratio）取值$r_{1},…,r_{m}$。 当使用这些比例和长宽比的所有组合以每个像素为中心时，输入图像将总共有$wℎnm$个锚框。 尽管这些锚框可能会覆盖所有真实边界框，但计算复杂性很容易过高。 在实践中，我们只考虑包含$s_{1}$或$r_{1}$的组合： $(s_{1},r_{1}),(s_{1},r_{2}),…,(s_{1},r_{m}),(s_{2},r_{1}),(s_{3},r_{1}),…,(s_{n},r_{1})$ 也就是说，以同一像素为中心的锚框的数量是$n+m−1$。 对于整个输入图像，将共生成$wℎ(n+m−1)$个锚框。(其实感觉还是很多) 交并比我们要如何衡量，某一个anchor是否很好覆盖了图像中的目标位置呢？也就是说我们需要衡量anchor和ground-truth bounding box之间的相似性，杰卡德系数(Jaccard)可以衡量两组之间的相似性。 给定集合A,B他们的杰卡德系数为他们交集的大小除以他们并集的大小。$$J(A,B)&#x3D;\\frac{A\\cap B}{A\\cup B}$$于两个边界框，它们的杰卡德系数通常称为交并比(intersection over union, IoU)，即两个边界框相交面积与相并面积之比。 使用非极大值抑制预测边界框在预测时，我们先为图像生成多个锚框，再为这些锚框一一预测类别和偏移量。 一个预测好的边界框则根据其中某个带有预测偏移量的锚框而生成。 当有许多锚框时，可能会输出许多相似的具有明显重叠的预测边界框，都围绕着同一目标。 为了简化输出，我们可以使用非极大值抑制(non-maximum suppression,NMS)合并属于同一目标的类似的预测边界框。 其主要工作原理如下： 对于每一个预测边界框B，目标检测模型会计算每个类别的预测概率。假设最大的预测概率为p，则该概率所对应的类别b即为其预测的类别。p称为预测边界框B的置信度。 在同一张图像中，所有预测的非背景边界框都会按照置信度降序排序，生成列表L。然后对L操作。 从L中选择置信度最高的预测边界框$B_{1}$作为基准，然后将所有与$B_{1}$的IoU值超过阈值$\\epsilon$的非基准预测边界框从L中移除。那些非极大值置信度的边界框被抑制了。 从L中选取置信度第二高的预测边界框$B_{2}$作为又一个基准，然后将所有与$B_{2}$的IoU大于$\\epsilon$的非基准预测边界框从L中移除。 重复上述过程，知道L中所有的预测边界框都层被用过，当作基准。此时，L中任意一堆预测边界框的IoU都小于阈值$\\epsilon$。所以没有一对边界框过于相似 输出列表L中的所有预测边界框。","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"研究生方向","slug":"研究生方向","permalink":"https://a-die.github.io/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B9%E5%90%91/"},{"name":"深度学习","slug":"深度学习","permalink":"https://a-die.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"【LeetCode周赛】LeetCode第358场周赛","slug":"【LeetCode周赛】LeetCode第358场周赛","date":"2023-08-14T02:52:39.059Z","updated":"2023-08-14T03:07:12.952Z","comments":true,"path":"2023/08/14/【LeetCode周赛】LeetCode第358场周赛/","link":"","permalink":"https://a-die.github.io/2023/08/14/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B%E3%80%91LeetCode%E7%AC%AC358%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"数组中的最大数对和给你一个下标从0开始的整数数组nums。请你从nums中找出和最大的一对数，且这两个数数位上最大的数字相等。返回最大和，如果不存在满足题意的数字对，返回 -1 。","text":"数组中的最大数对和给你一个下标从0开始的整数数组nums。请你从nums中找出和最大的一对数，且这两个数数位上最大的数字相等。返回最大和，如果不存在满足题意的数字对，返回 -1 。 示例 1： 输入：nums &#x3D; [51,71,17,24,42] 输出：88 解释： i &#x3D; 1 和 j &#x3D; 2 ，nums[i] 和 nums[j]数位上最大的数字相等，且这一对的总和 71 + 17 &#x3D; 88 。 i &#x3D; 3 和 j &#x3D; 4 ，nums[i] 和 nums[j]数位上最大的数字相等，且这一对的总和 24 + 42 &#x3D; 66 。 可以证明不存在其他数对满足数位上最大的数字相等，所以答案是 88 。 示例 2： 输入：nums &#x3D; [1,2,3,4]输出：-1解释：不存在数对满足数位上最大的数字相等。 提示：2 &lt;= nums.length &lt;= 1001 &lt;= nums[i] &lt;= 104 思路：首先根据nums.length可以知道数据范围并不大，因此我们可以直接暴力枚举整数数组nums中的两个数，判断这两个数数位上最大的数字是否相等。维护一个maxx用于存储最大和，若满足条件，即这两个数数位上最大的数字相等，则更新maxx。代码： 123456789101112131415161718192021class Solution &#123;public: int maxSum(vector&lt;int&gt;&amp; nums) &#123; int maxx=-1; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; int ma1=0,ma2=0,tmp1=nums[i],tmp2=nums[j]; while(tmp1)&#123; ma1=max(ma1,tmp1%10); tmp1/=10; &#125; while(tmp2)&#123; ma2=max(ma2,tmp2%10); tmp2/=10; &#125; if(ma1==ma2)maxx=max(maxx,nums[i]+nums[j]); &#125; &#125; return maxx; &#125;&#125;; 翻倍以链表形式表示的数字给你一个 非空 链表的头节点 head ，表示一个不含前导零的非负数整数。将链表 翻倍 后，返回头节点 head 。示例 1： 输入：head &#x3D; [1,8,9]输出：[3,7,8]解释：上图中给出的链表，表示数字 189 。返回的链表表示数字 189 * 2 &#x3D; 378 。 示例 2： 输入：head &#x3D; [9,9,9]输出：[1,9,9,8]解释：上图中给出的链表，表示数字 999 。返回的链表表示数字 999 * 2 &#x3D; 1998 。 提示：链表中节点的数目在范围 $[1, 10^4]$ 内$0 &lt;&#x3D; Node.val &lt;&#x3D; 9$生成的输入满足：链表表示一个不含前导零的数字，除了数字 0 本身。 思路：这道题主要考察的是对链表的操作，既然要对链表翻倍，那么我们一定要考虑到进位如何表示，可以先将链表进行翻转，翻转之后对链表的各个数字进行翻倍的操作会变得简单一些。最后再将链表翻转回来即可。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *reverse(ListNode *p)&#123; ListNode *q=NULL; while(p)&#123;//链表翻转 ListNode *x=(ListNode*)malloc(sizeof(ListNode)); x-&gt;val=p-&gt;val; if(q==NULL)&#123; q=x; q-&gt;next=NULL; &#125; else&#123; x-&gt;next=q; q=x; &#125; p=p-&gt;next; &#125; return q; &#125; ListNode* doubleIt(ListNode* head) &#123; int num=0; ListNode *p,*x,*q; p=head; q=reverse(p); ListNode *h=q; int pre=0; while(q)&#123;//将链表进行翻倍 int k=q-&gt;val; k*=2; q-&gt;val=k%10+pre; pre=k/10;//加在下一位上 q=q-&gt;next; &#125; h=reverse(h); if(pre)&#123;//如果最高位也需要进位 x=(ListNode*)malloc(sizeof(ListNode)); x-&gt;val=pre; x-&gt;next=NULL; x-&gt;next=h; h=x; &#125; return h; &#125;&#125;; 限制条件下元素之间的最小绝对差给你一个下标从 0 开始的整数数组 nums 和一个整数 x 。请你找到数组中下标距离至少为 x 的两个元素的 差值绝对值 的 最小值 。换言之，请你找到两个下标 i 和 j ，满足 abs(i - j) &gt;= x 且 abs(nums[i] - nums[j]) 的值最小。请你返回一个整数，表示下标距离至少为 x 的两个元素之间的差值绝对值的 最小值 。示例 1： 输入：nums &#x3D; [4,3,2,4], x &#x3D; 2输出：0 解释：我们选择 nums[0] &#x3D; 4 和 nums[3] &#x3D; 4 。它们下标距离满足至少为 2 ，差值绝对值为最小值 0 。 0 是最优解。 示例 2： 输入：nums &#x3D; [5,3,2,10,15], x &#x3D; 1输出：1解释：我们选择 nums[1] &#x3D; 3 和 nums[2] &#x3D; 2 。 它们下标距离满足至少为 1 ，差值绝对值为最小值 1 。 1 是最优解。 示例 3： 输入：nums &#x3D; [1,2,3,4], x &#x3D; 3输出：3解释：我们选择 nums[0] &#x3D; 1 和 nums[3] &#x3D; 4 。它们下标距离满足至少为 3 ，差值绝对值为最小值 3 。 3 是最优解。 提示：$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$$1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$$0 &lt;&#x3D; x &lt; nums.length$ 思路：看到数据范围，知道暴力枚举方法必定会时间超限，看到两个下标，我第一眼想到的就是双指针，滑动窗口的方法。当我们处理第i个数的时候，如果i+x以及之后的数是有序的，那么我们可以通过二分很快计算出最接近与nums[i]的数。如何维护这个有序的序列呢。数据结构set可以保证集合的有序，使用multiset可以保证序列中存在重复的数字。所以我们初始化一个multiset，命名ms，一开始将从x位置往后的所有数字都插入ms中。从下标为0的位置i开始逐一枚举，找到和其下标距离大于等于x且与其最相近的一个数，可以使用lower_bound找到第一个大于等于该数的数a。但是与此同时，我们还需要考虑这个数字a的前一个数字(即小于该数的最大的数)，计算这两个数和nums[i]的差值，维护最小值即可。然后开始移动窗口，往右移动一格，则第i+x的数需要移出，因为距离小于x了。然后还需要将i+1-x位置的数移入，因为该位置距离为x。代码： 12345678910111213141516171819class Solution &#123;public: int minAbsoluteDifference(vector&lt;int&gt;&amp; nums, int x) &#123; if(x==0)return 0; multiset&lt;int&gt;ms;//用来维护一个有序的集合 int n=nums.size(); for(int i=x;i&lt;n;i++)ms.insert(nums[i]); int ans=1e9; for(int i=0;i&lt;n;i++)&#123; auto it=ms.lower_bound(nums[i]);//找到后面的大于等于nums[i]的最小的数字 if(it!=ms.end())ans=min(ans,*it-nums[i]); if(it!=ms.begin())ans=min(ans,nums[i]-*prev(it));//找到该数字的前一个数字 //移动窗口 if(i+x&lt;n)ms.erase(ms.find(nums[i+x]));//往后移动，移除 if(i+1-x&gt;=0)ms.insert(nums[i+1-x]);//这个位置的数也符合要求了 &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://a-die.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://a-die.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"比赛","slug":"比赛","permalink":"https://a-die.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2022四非计算机保研经验","slug":"2022四非计算机保研经验","date":"2022-11-11T02:07:21.818Z","updated":"2022-11-11T02:12:37.468Z","comments":true,"path":"2022/11/11/2022四非计算机保研经验/","link":"","permalink":"https://a-die.github.io/2022/11/11/2022%E5%9B%9B%E9%9D%9E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/","excerpt":"希望能够帮助同样是四非的同学一点点，虽然最后本人上岸并不是梦校csu…… 最终上岸nuaa电子信息，面试rk前20，不知道有没有机会调成学硕…… 个人情况本科：湖南某四非 专业：计算机科学与技术 GPA：4.01&#x2F;5.00(2&#x2F;98) 英语：四级飘过，六级差一点 竞赛：若干国奖（计算机设计大赛，服务外包大赛，蓝桥杯，天梯赛个人奖等水奖），若干省奖 科研：SCI四区CV方向水论文一篇(导师一作，本人二作) 其他：推免综合排名本校第一，两项计算机软件著作权，获得国家奖学金","text":"希望能够帮助同样是四非的同学一点点，虽然最后本人上岸并不是梦校csu…… 最终上岸nuaa电子信息，面试rk前20，不知道有没有机会调成学硕…… 个人情况本科：湖南某四非 专业：计算机科学与技术 GPA：4.01&#x2F;5.00(2&#x2F;98) 英语：四级飘过，六级差一点 竞赛：若干国奖（计算机设计大赛，服务外包大赛，蓝桥杯，天梯赛个人奖等水奖），若干省奖 科研：SCI四区CV方向水论文一篇(导师一作，本人二作) 其他：推免综合排名本校第一，两项计算机软件著作权，获得国家奖学金 我在英语上特别吃亏，但是在面试过程中，其实可能是我准备得充分吧(从暑假夏令营就开始准备各种英文问题)，在面试的时候英语问题基本上都回答上来了(也有可能我面的都不是非常厉害的学校，因为厉害的学校也不会给本四非面试机会) 前期准备在基本上稳住保研名额之后，暑假前我就开始了夏令营的准备。因为本人四非，知道会被很多学校卡本科学历和英语成绩，于是选择了海投。投了大概10多所学校，入营五所(呜呜，四非太难啦)。 其实夏令营的面试，首先投递材料，准备好成绩单，排名证明，四六级证明，学生证，身份证，获奖证明，科研项目证明，论文，个人陈述等材料，有些学校还需要盖学院章的报名表(当时报的太多了，每次都是攒一堆一起去盖章)。 其次，主要复习专业课，未来方向(我是做的CV，所以说也是未来希望做CV)知识准备，自我介绍PPT，还有英语的自我介绍和英语问题(有关英语的问题在知乎上可以找到很多，然后自己整理整理即可，英语准备好在后面帮了我大忙，虽然我英语不太好，但是问题都答上来了)。 专业课方面主要就是408吧，个人认为数据结构和操作系统最重要，其他两门暂时没被问过，然后可以参考面试院校考研的专业课，也很可能是会被问的。未来人工智能是大势所趋，ML和DL能够了解就更好了(发论文大佬除外，肯定都已经精通了)。 夏令营情况投了很多所，只说说入营的吧。985基本上不要四非，只有海王中南给了面试机会(&#x2F;(ㄒoㄒ)&#x2F;~~) 学校 结果 中南大学 第二批优营(基本上都发了，太海了) 南京邮电大学 报名就入营，写一篇报告，背景面，最后无用 云南大学 优营(稳的) 深圳大学 优营(发了很多，但是好像也是稳的) 杭州电子科技大学 优营 中南大学中南太海了，入营了一堆，我是第二批入营的，但是咱们学校也就只入了我一个，好像还是小小刷了一波人，但面试还是很赶的感觉。csu是我梦校，虽然知道它很海，但是这几年本校都有去csu的，所以还是报了很大希望，但是最后还是被鸽了。面试大概10min吧。 先是3minPPT自我介绍，然后老师问到我的竞赛和项目中代码是不是都是自己写的(emmm当然自己写的啦)。接着老师开始问我的科研项目，介绍了一下我做了迁移学习和模型融合巴拉巴拉，问到我论文所做的工作是什么，发表的期刊是哪个。主要就是拷打项目吧。 最后来了一个英文的自我介绍，欢迎报考就再见了。 结果：虽然拿了优营，但是中南海王基本上都发了，等于没发，最后还是没去成梦校，难过 南京邮电大学报名即入营，听讲座，写报告，根据背景和报告打分，emmm基本上四非也不会有机会的，最后gg。 云南大学云南大学是偏远地区的211，还是不歧视咱们四非的(可能也招不到啥人)。 5minPPT自我介绍，然后因为PPT里面展示了部分学科的成绩，让我介绍了一下设计模式中的工厂模式(学的都忘了呜呜，答得稀烂)，然后问了一下软件著作权，英语问题问的是**Please talk about your major?**也不是很难。 结果：优营，不过入营即优营 深圳大学深圳大学现在越来越强了，当时也是好好考虑了一下去不去。 深圳大学的老师超级好，每一个参加夏令营的学生都是一个一个打电话过去面试，呜呜呜每个老师都好好。 深大一上来就是数学问题拷打 先验概率和后验概率都分别是什么？简单介绍一下 简单讲讲线性代数中你记得的部分。 因为第2个问题谈到了秩，于是问什么是秩 用数学方式说一下梯度下降法 这几个问题说难也不难，但是数学那个时候确实没咋复习，概念都忘得差不多了。梯度下降法倒是因为那个时候一直在做CV，也能够回答得上来。 结果：优营，听说发了几百。 杭州电子科技大学hdu夏令营宣讲的时候感觉好强，据说cs要升到A-了。 先是3min直接自我介绍，然后又是开始拷打我的项目，为什么使用迁移学习？介绍一下论文等等。项目问题因人而异吧，不过毕竟是自己做的，所以回答起来都不会太难。(特别喜欢项目问题) 结果：优营，只发了20多个。 总结怎么说呢，今年特别卷，夏令营四非根本进不了几个学校，而且像中南，虽然给了机会，但是超发优营。害，建议四非同学们在保证高绩点rk的情况下，要多卷卷科研，这样入营之后才有了很多和老师沟通的权力。 预推免情况以前的学长学姐大多数都是预推免上岸的，bar比夏令营低。 今年不一样啊，该卷还是卷，湖大又是放很多人面试，南航1400人面试……众多的211报名即可参与面试，害，不过总比不给机会要好。要交的材料其实和夏令营差不多，很多学校没有夏令营，只有预推免，所以这个时候对于四非er们来说，可以选择的学校又多了很多。 我在预推免时同样也是海投，所以也只说说进了面试的学校。 学校 结果 南京航空航天大学 电子信息专硕rk前20，当时是把南航当保底学校了 湖南大学 第二批电子信息专硕rk前60，感觉是不太稳，但是听说后面也被鸽穿了。 南京理工大学 初审通过，询问是否直博，拒绝直博后惨遭南理工拒绝 湖南师范大学 湖师大应该对本省我们学校来说是兜底的，面试了就给机会 暨南大学 电子信息专硕rk前30，发了拟录取 北京工业大学 面试那天一共有四个学校的面试，感觉很累，而且最终应该也不会去北京，遂放弃面试 武汉理工大学 发了拟录取 南京航空航天大学当时看到南航给了1400多人面试机会，觉得自己肯定没啥机会了，不过最后的结果还挺不错，这也是我的最终去向。 英语+项目拷打 一上来先是英语问题 谈谈你的兴趣爱好 在本科阶段做的科研项目 在本科阶段你遇到的挑战 这三个问题也都还好，偏生活方面的问题，前期也都准备了许多，答得还不错。 然后就是项目的拷打了 老师好像一眼发现了我发的是水刊，问了我何时发表和见刊的，间隔时间太短了…其他的就是正常介绍项目，然后详细讲了一遍。问了迁移学习有什么难点…….不太记得了，但是问项目真的比专业课好很多，自己最近才仔细钻研过的东西都能回答得上来。 结果：电子信息rk前20，还不错，稳啦。面试结束后第二天，就收到了一个导师的电话，说对我很感兴趣，当时我直说我想去csu，然后老师说一直给我留名额，如果不能去csu再来找他，真的导师很好。 湖南大学湖大也很海，湖南两海王之一，不过既然给了面试机会，还是好好参与一下 英语自我介绍+英语问题+项目问题 英语自我介绍之后，两个英语问题 介绍你的本科学校 谈谈兴趣爱好 也都是生活方面的英语问题，不难 吐槽一下，湖大面试平台感觉真的很卡欸，没有腾讯会议好用，期间总是要老师重复一下问题 最后就又是问项目了，还问到了一些竞赛之类的。 结果：电子信息rk前60，停靠后的，因为湖大面了两批预推免，夏令营还有一批，但最后听说被鸽穿了，咱也不知道有没有机会。 南京理工大学本来在通过初审之后，人家都是很快收到面试消息，但是南理工对四非都发了邮件询问是否直博，然后我拒绝之后，也没有给我面试机会了(&#x2F;(ㄒoㄒ)&#x2F;~~) 湖南师范大学湖师大面试还是挺水的(好像他们也招不太满)，在中文和英文自我介绍后，询问了项目中所写的论文，我做了什么，介绍了一下论文。最后说如果确定去他们学校需要今晚给答复。 结果：应该是稳了，但是要晚上给明确答复，遂拒绝。 暨南大学暨大也挺海的，放所有报名的人进入面试。其实我也是将其作为保底学校的(为什么都是保底，因为想冲csu呜呜呜)，但是最后好像我点确定复试太慢了，都已经招满了。 PPT自我介绍+专业课问题+项目问题 自我介绍没啥说的，好好展现自己就行。 专业课问题问了数据结构和操作系统 介绍一下排序算法 讲讲这些算法的时间复杂度，谁最快 操作系统问了啥上下文切换 操作系统这边，感觉我们本科老师没有谈到过这个方面，我复习的时候也没有影响，于是直接说了操作系统都不太记得了，然后就没问了(应该这里减了挺多分)。 项目问题还好啦，老师都挺关注科研和论文的。 结果：拟录取，应该是稳的 北京工业大学面试那天是周日，同时有四个面试，虽然没有撞在一起，但是在我面完两个学校之后，真的好累，也不知道为啥还emo了一下，最终放弃面试 武汉理工大学武理的面试也挺随意的，每个人5min，先是自我介绍，然后问了个项目里面数据集怎么来的和怎么处理的，最后询问武理是否是第一志愿，便结束了。 结果：拟录取，同学系统填报了武理的最终都收到了武理发来的拟录取，所以应该也是稳的。 总结小小总结一下，感觉211的话，对咱们四非来说，应该是面一个进一个的。bar不高，拿到offer的概率也挺大(我面试的都拿到了)。预推免这段时间也是真的煎熬，每天都在投学校，20号之后还有扎堆的面试，不过最后结果还不错吧对本四非来说，offer还是拿到了几个。 写在后面填报系统我填的是中南，南航，暨大，想冲冲csu，保底留两个。 在通过csu的面试之后，我还联系了csu的一个年轻强导，导师和我面试了40min，主要是自我介绍和编程能力的展示，不过导师最后也没给准信吧，还是得看招办，听说csu强com，导师没有一点话语权。 928填报系统当天，听说很多uu收到了csu的电话，学长那边也感觉我肯定能上csu，一直要我不要担心，放宽心。虽然这么说吧，但是我还是感觉今年形势和他们不太一样，有保研名额的人多了太多了，而且出国的人变少了，挺多佬保本校，名额就更少了。 当天12点，复试通知各学校都发得很积极，我也一直在等csu的拟录取(虽然最后也没等到)，今年南航不知道干啥去了，一直等到快两点才发来复试通知，当时可慌了，还想不会面试前20，南航都没机会了吧。 期间给csu招办打了三个电话，一开始问我是否接受调剂到通信工程或者软件工程，我选择如果要调剂的话可以到软件工程。最后呢，南航也发拟录取过来了，我最后一次打电话给csu，问需要多久可以确定我是否被录取，答复为1-2小时，再等了20min之后，怕南航这边拟录取也撤回了，最后忍痛放弃csu。 不过南航也很不错啦，有一个一直给我留名额的导师，和他商量之后也可以做我未来想做的方向，虽然最后也难过了一下，但是在朋友们的开导下，现在好很多了。本四非能够冲上一个很好的211，还有一个想要自己的导师~~ 保研之路终于暂时落下了帷幕了，准备这几天好好休息休息，然后联系导师，看看未来需要学些啥。希望我未来在南航能够再上一层楼吧！ 卷了三年，将近半年的精神内耗，数天的彻夜难眠，都结束了。如有野心未泯，那就沉潜三年，再等下一场秋风眷顾。","categories":[{"name":"总结","slug":"总结","permalink":"https://a-die.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"https://a-die.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"第十三届服务外包创新创业大赛总结&经验分享","slug":"第十三届服务外包创新创业大赛总结","date":"2022-11-10T07:17:26.911Z","updated":"2022-11-11T02:11:25.416Z","comments":true,"path":"2022/11/10/第十三届服务外包创新创业大赛总结/","link":"","permalink":"https://a-die.github.io/2022/11/10/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/","excerpt":"前言比赛已经过去几个月了，也算是想起来这个比赛可以写一个总结了。在历时8个月左右的时间之后，我们队伍最终获得了中南赛区区域赛一等奖，全国总决赛二等奖的成绩。","text":"前言比赛已经过去几个月了，也算是想起来这个比赛可以写一个总结了。在历时8个月左右的时间之后，我们队伍最终获得了中南赛区区域赛一等奖，全国总决赛二等奖的成绩。 谈及这8个月的经历，从最初的组队，选题，到中期的区域赛答辩，再到最后的决赛答辩，每一步我们都花费了很多的时间。因为有了第十二届参赛的经验，这次我们的目标就是要拿国一，虽然最终以国二收尾，但是其中每个人都付出了很多。无数次的排练和开会，为最后的获奖奠定了基础。 其实近几年，这个比赛的获奖难度也越来越大了，各大院校的学生也都越来越卷，第十二届比赛我们学校大二的队伍有几个队伍进了决赛，而第十三届的比赛大二队伍只有一个队进入决赛。所以大家如果想要在这个比赛中获得好的名次，需要付出的努力是往年不可及的。 因此，我将此次比赛的几个关键节点，我们队伍的处理和解决方法记录，进行一个总结和经验的分享。 组队＆选题因为我有保研的想法，所以是尽可能参加各种比赛，因此早在学校开始组织报名之前，我便开始组队了。因为这个比赛除了实现企业所要求的技术点和功能，还需要制作视频和PPT，进行材料的上交和答辩的演示。所以在组队时，需要考虑到这个因素，需要安排一个合适的同学去进行视频的学习和制作。对于大一大二的同学来说，可能很多的技术都没有学习，所以大家一定要抱着愿意去学习的心态来参加比赛，比赛之后肯定能够学到很多(我大二参加的是第十二届比赛，那时候什么也不会，但是最终一边学习一边比赛拿到了国三，而且学到了很多的技术知识，对我后续上课的学习也帮助很大)。 大家不要害怕自己什么都不会，很多同学的技术都是报名了之后才开始学的，是完全有时间的，只要你愿意花时间学，一切皆有可能。 至于选题，我们每个人都对所有的选题浏览了一遍。因为参加了两届，我认为第十三届的选题与第十二届相比，技术性高了很多，第十三届的大部分选题都与人工智能有关，对于我们这种普通双非学校，接触到的人工智能知识很少，所以需要学习的知识点也不少。而未来的趋势肯定是向人工智能发展的，所以未来人工智能类的题目只会多不会少。但是大家也不要惧怕此类题目，我们目前来学习是完全有时间的，而且这个工作可以分配给未来想要读研的同学，与其来说也是有益的。 选题时，大家可以慢慢缩小范围，先筛掉自己不擅长，或者是学习该方面对未来没什么帮助的题目。比如我们首先就筛掉需要硬件的题目(大家都不擅长而且未来不考虑该方向)，然后分析每道题目的技术点，最终圈定题目。 在经过了讨论之后，我们选择了 [A14]赋能垃圾分类真正落地见实效的信息系统 的题目。因为该题目中，可以做的东西很多 官方提供了三个可做的点，因此可以做的技术和功能有很多，可以很方便进行扩展，而且也可以结合很多的创新点。从其他题目中寻找技术点来作为本题目的创新点也是可以的，我们就从A29一个AR选题中得到启发，计划融入AR来作为我们的创新点。 我们一开始也计划完成一个人工智能算法，来提高本项目的一个技术层次，但是我们也留了个退路，就是该题目的算法可以不完成，完成第一点也是可以的。(最终也是人工智能算法也完成了，并且发表了一篇paper) 我们最终五人的总体分工如下： 人工智能算法 Android开发 后端开发&amp;Android开发 AR创新点 Android开发&amp;视频，PPT制作 作为组长，我的任务是人工智能算法的开发和协调小组内工作的进行。组长在比赛中肯定要发挥更大的作用，每周的开会，总结，后续的任务安排，组织成员沟通等等……小组内良好的氛围也是很重要的，我们组当时氛围就很好，待一块就是很好的沟通然后开始聊天(bushi。 此外，也要多和指导老师沟通，我们每次和指导老师开完会之后，都能得到很多新的idea和需要改进的点。 总的来说，组队时主要需要大家都对未来抱有信心，而且有能力而且保证自己能够去学习新知识。 选题时需要大家多进行头脑风暴进行讨论，对每个选题进行分析，最终共同敲定题目。 分工&amp;项目推进刚刚也谈及了我们几个人的分工。这是在选题之后就马上初步定下来的结果，因为临近寒假，必须马上敲定任务，才能好好地利用这个假期。 人工智能算法 Android开发 后端开发&amp;Android开发 AR创新点 Android开发&amp;视频，PPT制作 这都是一个大范围的分工，我们在做好自己的工作之后，也都会问其他成员的建议。毕竟是一个团队，同心协力才能做到最好。 此外，对于这个比赛，我们必须从技术创新，商业创新，功能创新等几个角度的创新点出发，来确定需要自己所设计的系统的功能，这也是评委们很看重的。比如我们这个赛题，我们从3D游戏科普垃圾分类知识，志愿活动联系生活进行环保，算法采用迁移学习模型融合提高泛化性……从多元角度出发，但是不要走题，对项目进行创新。 我负责的是人工智能部分，这是我们没有接触过的板块，所以刚放寒假我便开始学习，一边学习一边做一些实践。最终该算法也是完成了，并且发表了一篇论文。所以大家不要惧怕自己没有学过的东西，只要用心，一切都来得及。 在寒假时，我们每周都会进行一次开会，而且老师不时地也会参与。 整个比赛下来，我们记录了很多，所以也推荐大家每次将会议内容记录下来，然后记录每周做了什么，下周要做什么，整个团队互相监督。 作为组长，也需要督促起这个每周会议的任务，保证大家的进度不会落下。 在寒假后，大家也有繁重的学业任务，所以寒假时大家一定要花多一点时间学习和开发项目，开学后才不至于不好兼顾比赛和学习。 区域赛的后期就是提交文档和PPT以及视频，4月处之前大家项目基本完成之后就可以开始这个工作了，就算项目完成不了，大家也一定要想办法体现自己的idea，不一定要实现，但是一定要体现出来。最后的文档，PPT，视频，参考往届模板，做的漂亮一点。 提交材料&amp;项目答辩四月底便是提交材料的时候了，在此之前大家一定要确定好官方提供的“提交材料”和“任务清单”是什么，以免漏掉了一些必要的提交的文件。材料的提交只在第一轮区域赛初赛中起到作用，评委们会根据调教的材料来对你们的项目进行打分。其实主要看的就是PPT和视频，这两个东西一定要做得好(很多功能就算没有实现，在PPT和视频中也要包装好让评委们看见)。 区域赛初赛很幸运，我们在区域赛初赛是以该选题第一名的排名进入了区域赛决赛，因为有我们做的非常好的PPT和视频哈哈哈哈，当然也少不了其他成员的共同努力，不断修改的Android的UI设计，不断提高的算法准确率，不断完善的3D小游戏…… 区域赛决赛在材料提交之后，过半个月便是该比赛的区域赛决赛答辩。答辩需要组内敲定答辩人，修改好讲解的PPT和视频，准备好各种问题以备评委老师提问。在这半个月里，老师也对我们进行了数次的答辩指导，我们也不断整理问题，每个同学负责一个板块来回答。 在此轮答辩中，老师提问的主要是算法部分的技术点，对于该部分我也做了充足的准备。 最终也晋级啦，走到了最后一步——决赛答辩。 全国总决赛这一轮同样也是答辩，时间在暑假的8月份左右，但是竞争对手是每个区域的佼佼者。我们在答辩完成之后，感觉有些良好。但是老师的一个提问“你们所提到的北纬公司是真的存在的吗？”，我们起初以为这个点不重要，毕竟哪个学生开公司呀。 但是这才是决赛评委们真正会在意的点——商业价值，如果说区域赛决赛考察的是技术点，那么决赛看重的就是你这个项目的商业模式和价值。所以评委针对我们是否真的有这个公司进行了提问，还问了很多有关我们项目如何推广的问题。 在决赛的颁奖典礼上，我们看到了很多个团队落地的项目，才知道真的有很多团队他们是真的完成了商业的推广，还有了很多的用户群体，项目成功落地，让我们感到自愧不如。这个比赛毕竟叫做“创新创业大赛”，评委们也都是企业的代表，自然会对你这个项目的后续推广产生极大的兴趣，而我们的项目没有落地，都只是自己的计划和方案。 最终，也是遗憾拿到了全国二等奖，没有达到我们最初的预期。 总的来说，如果大家想要一路成功站在最后，除了功能和技术点的完成，商业价值也一定要注重，做到一个落地的项目，是很受企业青睐的。 写在最后先总结一下，给大家提一些建议： 及时组队，确保团队每个人都愿意学习新知识(不要怕这些技术点没有学过，从头开始学都是来得及的，大家都是这样)。 在项目执行过程中，确保团队每个人都在跟进项目，每过一段时间要有产出，必要的一些任务需要设置ddl，保证大家完成。 对于组长，需要付出更多，组织大家开会，分配工作到每个成员，检查成员工作，以身作则完成自己的任务。 对于组员，按时完成分配的任务，遇到问题及时提出沟通，大家共同解决。 指导老师也是很重要的“资源”，老师可以提供给你方向和学习的路线，以及一些创新的idea。 文档撰写也要仔细，格式不要乱。视频和PPT注重美观和整洁，突出创新点，图多字少，抓住评委眼球。 其实过了这么多月了，现在回想起来这个比赛，历时大半年，和团队一起也相处了很久，收获到的，不仅仅是最后的奖状，也有很多对自己有益的知识，更重要的还有团队五人的友谊！ 生活明朗，万物可爱，人间值得，未来可期","categories":[{"name":"总结","slug":"总结","permalink":"https://a-die.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"https://a-die.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"比赛","slug":"比赛","permalink":"https://a-die.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"服务外包","slug":"服务外包","permalink":"https://a-die.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-08T12:32:02.112Z","updated":"2022-11-10T13:25:04.609Z","comments":true,"path":"2022/11/08/hello-world/","link":"","permalink":"https://a-die.github.io/2022/11/08/hello-world/","excerpt":"这里是a碟，主要是觉得，现在在往深度学习方面研究，有时候还是得做一下笔记。当然也不止是记录这一块啦。 搭建这个博客的话，除了在自己电脑上能看到，在别的地方看也方便了很多。 &#x3D;&#x3D;希望大家能够一起进步！&#x3D;&#x3D;","text":"这里是a碟，主要是觉得，现在在往深度学习方面研究，有时候还是得做一下笔记。当然也不止是记录这一块啦。 搭建这个博客的话，除了在自己电脑上能看到，在别的地方看也方便了很多。 &#x3D;&#x3D;希望大家能够一起进步！&#x3D;&#x3D;","categories":[],"tags":[]}],"categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://a-die.github.io/categories/LeetCode/"},{"name":"总结","slug":"总结","permalink":"https://a-die.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"研究生方向","slug":"研究生方向","permalink":"https://a-die.github.io/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%96%B9%E5%90%91/"},{"name":"深度学习","slug":"深度学习","permalink":"https://a-die.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"目标检测","permalink":"https://a-die.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"算法","slug":"算法","permalink":"https://a-die.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"比赛","slug":"比赛","permalink":"https://a-die.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"经验分享","slug":"经验分享","permalink":"https://a-die.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"服务外包","slug":"服务外包","permalink":"https://a-die.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85/"}]}